name: Deploy Backend

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build backend image
        run: |
          docker build -t school-backend:${{ github.sha }} .
          docker save school-backend:${{ github.sha }} | gzip > backend-image.tar.gz

      - name: Create production docker-compose.yml
        run: |
          # Create production version of docker-compose.yml that uses image instead of build
          IMAGE_TAG="${{ github.sha }}"
          cat > docker-compose.prod.yml << EOF
          version: '3.3'
          
          services:
            web:
              image: school-backend:${IMAGE_TAG}
              container_name: school-backend
              env_file:
                - .env
              ports:
                - "8000:8000"
              volumes:
                - ./logs:/app/logs
              depends_on:
                - mongo
              networks:
                - school-network
              restart: unless-stopped
          
            mongo:
              image: mongo:7.0
              container_name: school-mongo
              command: ["--bind_ip_all"]
              volumes:
                - ./mongo-data:/data/db
              networks:
                - school-network
              restart: unless-stopped
          
          networks:
            school-network:
              driver: bridge
          EOF

      - name: Upload deployment files artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-files
          path: |
            backend-image.tar.gz
            docker-compose.prod.yml

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download backend files artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-files
          path: .

      - name: Copy files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          source: "docker-compose.prod.yml,backend-image.tar.gz"
          target: "${{ secrets.VPS_DEPLOY_BACKEND_PATH }}/"

      - name: Deploy on VPS
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USER }}
          key: ${{ secrets.VPS_SSH_KEY }}
          script: |
            set -e
            DEPLOY_PATH="${{ secrets.VPS_DEPLOY_BACKEND_PATH }}"
            cd "$DEPLOY_PATH"
            
            # Verify required files exist
            echo "üîç Verifying files..."
            if [ ! -f "backend-image.tar.gz" ]; then
              echo "‚ùå backend-image.tar.gz not found"
              ls -la
              exit 1
            fi
            
            if [ ! -f "docker-compose.prod.yml" ]; then
              echo "‚ùå docker-compose.prod.yml not found"
              ls -la
              exit 1
            fi
            
            if [ ! -f ".env" ]; then
              echo "‚ö†Ô∏è .env file not found. Creating template..."
              echo "# .env file should be created during initial setup" > .env.template
              echo "‚ö†Ô∏è Please ensure .env file exists with proper configuration"
            fi
            
            # Rename docker-compose.prod.yml to docker-compose.yml for use
            cp docker-compose.prod.yml docker-compose.yml
            
            # Load Docker image
            echo "üì¶ Loading Docker image..."
            docker load < backend-image.tar.gz
            
            # Verify image loaded
            IMAGE_TAG="${{ github.sha }}"
            if ! docker images | grep -q "school-backend.*${IMAGE_TAG}"; then
              echo "‚ùå Failed to load image school-backend:${IMAGE_TAG}"
              echo "Available images:"
              docker images | grep school-backend || echo "No school-backend images found"
              exit 1
            fi
            echo "‚úÖ Image loaded: school-backend:${IMAGE_TAG}"
            
            # Use docker-compose (with hyphen) if available, otherwise docker compose
            if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            elif docker compose version &> /dev/null 2>&1; then
              COMPOSE_CMD="docker compose"
            else
              echo "‚ùå Neither docker-compose nor docker compose found"
              echo "Installing docker-compose..."
              sudo curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
              COMPOSE_CMD="docker-compose"
            fi
            
            # Ensure network exists
            echo "üåê Ensuring Docker network exists..."
            docker network create school-network 2>/dev/null || echo "Network already exists"
            
            # Start MongoDB first (if not running)
            echo "üöÄ Starting MongoDB..."
            $COMPOSE_CMD up -d mongo
            
            # Wait for MongoDB to be ready
            echo "‚è≥ Waiting for MongoDB to be ready..."
            for i in {1..30}; do
              # Try multiple ways to check if MongoDB is ready
              if docker exec school-mongo mongosh --eval "db.adminCommand('ping')" >/dev/null 2>&1 || \
                 docker exec school-mongo mongo --eval "db.adminCommand('ping')" >/dev/null 2>&1 || \
                 nc -z localhost 27017 2>/dev/null; then
                echo "‚úÖ MongoDB is ready"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "‚ùå MongoDB failed to start after 60 seconds"
                echo "MongoDB logs:"
                docker logs school-mongo --tail 50
                echo "MongoDB container status:"
                docker ps -a | grep mongo
                exit 1
              fi
              echo "‚è≥ Waiting for MongoDB... ($i/30)"
              sleep 2
            done
            
            # Verify MongoDB container is in the network
            echo "üîç Verifying MongoDB network..."
            if ! docker network inspect school-network | grep -q school-mongo; then
              echo "‚ö†Ô∏è MongoDB container not in network, recreating..."
              $COMPOSE_CMD up -d --force-recreate mongo
              sleep 5
            fi
            
            # Start/update web service
            echo "üöÄ Starting web service..."
            $COMPOSE_CMD up -d --no-deps web
            
            # Verify containers are running
            echo "üîç Verifying containers..."
            sleep 3
            if ! docker ps | grep -q school-backend; then
              echo "‚ùå school-backend container not running"
              echo "Container logs:"
              docker logs school-backend --tail 50 || true
              exit 1
            fi
            echo "‚úÖ Container school-backend is running"
            
            # Health check
            echo "üè• Running health check..."
            sleep 5
            for i in {1..10}; do
              if curl -fsS http://localhost:8000/api/v1/health >/dev/null 2>&1; then
                # Verify health check response
                HEALTH_RESPONSE=$(curl -s http://localhost:8000/api/v1/health)
                if echo "$HEALTH_RESPONSE" | grep -q '"status":"ok"'; then
                  echo "‚úÖ Health check passed"
                  echo "Health status: $HEALTH_RESPONSE"
                  exit 0
                else
                  echo "‚ö†Ô∏è Health check returned degraded status: $HEALTH_RESPONSE"
                fi
              fi
              echo "‚è≥ Waiting for backend to be ready... ($i/10)"
              sleep 2
            done
            
            echo "‚ùå Health check failed after 20 seconds"
            echo "Backend logs:"
            docker logs school-backend --tail 50
            echo "Health check response:"
            curl -s http://localhost:8000/api/v1/health || echo "Cannot reach health endpoint"
            exit 1

